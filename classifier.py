# -*- coding: utf-8 -*-
"""02806_Classifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JS7PP4Js1UsSN-FLx0_4ALKnoLO4021A
"""

import pandas as pd
import numpy as np
import urllib.request as urllib2
from datetime import datetime, timedelta, date

"""### Get Oxford data and calculate Death Rate"""

# Import Oxford data and enrich columns for future merging needs
df = pd.read_csv('https://raw.githubusercontent.com/OxCGRT/covid-policy-tracker/master/data/OxCGRT_latest.csv')
df['Date'] = pd.to_datetime(df['Date'], format="%Y%m%d")
df['DateString'] = df['Date'].apply(lambda x: datetime.strftime(x, "%Y%m%d"))
df['Index'] = df['CountryCode'] + df['DateString']

# Calculate Death Rates
df['DeathRate'] = df['ConfirmedDeaths'] / df['ConfirmedCases'] *100

"""### Get Market data and calculate Market Performance"""

stocks = pd.read_csv('https://raw.githubusercontent.com/LarsBryld/socialdataanalysis2020/master/data/Markets.csv',
                     encoding= 'unicode_escape'
                    )
stocks = stocks.groupby('CountryCode',sort=False).sum()
#stocks = stocks.rename({'United Kingdom': 'United Kingdom'}, axis='index')
#stocks = stocks.drop(columns=['Index ', 'Country/Region'])

columns_new = np.array(stocks.columns)
for i in range(len(columns_new)):
    columns_new[i] = datetime.strptime(columns_new[i],'%d/%m/%Y')

stocks.columns = columns_new

# Reference dates: 23rd and 24th March 2020

market0 = stocks[datetime(2020, 3, 23, 0, 0)]
for i in (8, 9, 10, 16, 17, 20, 21, 27, 29, 30, 31, 32):                            #range(1,len(stocks)):
    market0.iloc[i] = stocks[datetime(2020, 3, 24, 0, 0)][i]

# Market Performance
mkt_p = stocks.T/market0 -1
mkt_p = mkt_p.T *100
#mkt_p = mkt_p.reindex(focuscountries)

# showing perfomances from 23rd March onward
mkt_p.iloc[:, 81::].head()        # TO BE DELETED

# Converting Market Performances data from rows to columns
mkt_p1 = pd.DataFrame(mkt_p[mkt_p.columns[0]])
mkt_p1['Date'] = mkt_p1.columns.repeat(len(mkt_p1))
mkt_p1.rename(columns={mkt_p1.columns[0]:'MarketPerformance', 'Date':'Date'}, inplace=True)

for i in range(1, len(mkt_p.columns)):
    mkt_p_new = pd.DataFrame(mkt_p[mkt_p.columns[i]])
    mkt_p_new['Date'] = mkt_p_new.columns.repeat(len(mkt_p))
    mkt_p_new.rename(columns={mkt_p_new.columns[0]:'MarketPerformance', 'Date':'Date'}, inplace=True)
    mkt_p1 = pd.concat([mkt_p1, mkt_p_new], axis=0)

mkt_p1.head()

# Adding columns needed for merging with Oxford data
mkt_p1['DateString'] = mkt_p1['Date'].apply(lambda x: datetime.strftime(x, "%Y%m%d"))
mkt_p1['Index'] = mkt_p1.index + mkt_p1['DateString']
mkt_p1.loc['USA']

# Add Market Performance to Oxford file 
df = df.merge(mkt_p1, left_on = 'Index', right_on = 'Index', how = 'left')
df = df.rename({'Date_x': 'Date',
                'DateString_x': 'DateString'}, axis='columns')
df = df.drop(columns=['Date_y', 'DateString_y'])
df[df['CountryCode']=='USA']

#data = df

"""## calculate CovIndex = Market Performance - Death Rate"""

df['CovIndex'] = (df['MarketPerformance'] - df['DeathRate']) #* 100
df = df[df['CovIndex'].notna()]



"""## Add more info:
- take snapshot o all indicators on 30th April (needed for classifier later on)
- sum all Fiscal and other economic measure up to 30th April
- divide them by GDP (World Bank data are available) to make all Countries measure comparable
"""



"""## Building the Classifier"""

good = ['USA', 'KOR', 'ZAF', 'FIN', 'AUS', 'DEU', 'CAN', 'GRC', 'JPN', 'NZL']
bad = ['ITA','FRA', 'SPA', 'GBR', 'BEL', 'SWE', 'NLD', 'CHN', 'IND', 'MEX']

# data preprocessing
import matplotlib.pyplot as plt
from sklearn.tree import plot_tree

# selecting our sample
# Oxford Data snapsot on 30th March
df1 = df[df['Date'] == datetime(2020, 3, 30, 0, 0)]
df1 = df1.iloc[:,1:-8]
df1 = df1.drop(columns=['Date', 'ConfirmedCases', 'ConfirmedDeaths'])
df1 = df1.fillna(0)

# Labels for classifiers
good = ['DEU','GRC','USA', 'KOR', 'BRA', 'ZAF', 'DNK']
bad = ['ITA','FRA','SPA', 'GBR', 'BEL', 'SWE', 'NLD']

df1['Label'] = 1
df1.loc[df['CountryCode'].isin(good), 'Label'] = 2
df1.loc[df['CountryCode'].isin(bad), 'Label'] = 0

# encoding string labels (Category is the target variable)
labels = df1['Label']

# Select the Features
features = df1.iloc[:,1:-1]

# DecisionTree Classifier
from sklearn import tree
clf = tree.DecisionTreeClassifier(criterion='gini')
clf = clf.fit(features, labels)

#plt.figure(figsize=(20,20))
#tree.plot_tree(clf, filled=True)
#plt.title("Decision trees on full data set")
#plt.show() 

# Predict Output
# predicted= clf.predict(features) # 0:Overcast, 2:Mild
# print(predicted)

# measuring the classification performance of the Tree classifier through cross_val_score
#from sklearn.model_selection import cross_val_score
#np.mean(cross_val_score(clf, features, label))#, cv=10))

X = df1[['C1_School closing', 'C2_Workplace closing', 'C3_Cancel public events', 'C4_Restrictions on gatherings', 'C5_Close public transport', 'C6_Stay at home requirements', 'C7_Restrictions on internal movement', 'C8_International travel controls', 'E1_Income support', 'H2_Testing policy', 'H3_Contact tracing'] ]
y = df1['Label']

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=1)

from sklearn import tree

model = tree.DecisionTreeClassifier()
#model
model.fit(X_train, y_train)

y_predict = model.predict(X_test)

from sklearn.metrics import accuracy_score


from sklearn.metrics import confusion_matrix

pd.DataFrame(
    confusion_matrix(y_test, y_predict),
    columns=['Predicted Bad', 'Predicted Indifferent', 'Predicted Good'],
    index=['True Bad', 'True Indifferent', 'True Good',]
)

accuracy_score(y_test, y_predict)

#tree.export_graphviz(model.tree_, out_file='tree.dot', feature_names=X.columns)
#from subprocess import call

#call(['dot', '-T', 'png', 'tree.dot', '-o', 'tree.png'])

plt.figure(figsize=(30,30))
tree.plot_tree(model, filled=True, feature_names=X.columns, class_names=['0', '1', '2'])
plt.title("Decision trees on full data set")
plt.show()

labels.unique()





#df.to_excel("Dataset.xlsx")